"""
Synthetic PCB Layout Generator

Generates realistic PCB layout features for training data:
- Copper density maps (traces, planes, pours)
- Via patterns (thermal vias, signal vias)
- Component placement with power dissipation
- Various board configurations

The goal is to create diverse, realistic PCB features that
capture the thermal behavior of real boards.
"""

import numpy as np
from typing import List, Tuple, Optional, Dict
from dataclasses import dataclass, field
import random


@dataclass
class Component:
    """Represents a heat-generating component"""
    name: str
    center_y: int
    center_x: int
    height: int
    width: int
    power: float  # Watts
    footprint_type: str = "QFP"  # QFP, BGA, SOT, TO, etc.
    

@dataclass
class Via:
    """Represents a via (thermal or signal)"""
    y: int
    x: int
    is_thermal: bool = False
    

@dataclass 
class PCBLayout:
    """Complete PCB layout data structure"""
    # Core features (input to ML model)
    copper_density: np.ndarray      # (H, W) copper fill ratio 0-1
    via_map: np.ndarray             # (H, W) via locations
    component_map: np.ndarray       # (H, W) component footprints
    power_map: np.ndarray           # (H, W) power dissipation W/m²
    
    # Metadata
    components: List[Component] = field(default_factory=list)
    vias: List[Via] = field(default_factory=list)
    board_size_mm: Tuple[float, float] = (100.0, 100.0)
    layer_count: int = 2
    
    # Labels (output - generated by thermal solver)
    temperature: Optional[np.ndarray] = None
    

class PCBGenerator:
    """
    Generates synthetic PCB layouts with realistic features.
    
    Design philosophy:
    - Create diverse copper patterns (planes, traces, pours)
    - Place components realistically (not overlapping, thermal considerations)
    - Add vias near heat sources and for layer transitions
    - Vary board complexity from simple to complex
    """
    
    def __init__(
        self,
        grid_size: Tuple[int, int] = (128, 128),
        seed: Optional[int] = None
    ):
        self.ny, self.nx = grid_size
        self.rng = np.random.default_rng(seed)
        
    def generate(
        self,
        complexity: str = "medium",
        num_components: Optional[int] = None,
        total_power: Optional[float] = None
    ) -> PCBLayout:
        """
        Generate a complete PCB layout.
        
        Args:
            complexity: "simple", "medium", or "complex"
            num_components: Override number of components
            total_power: Override total power dissipation (W)
            
        Returns:
            PCBLayout with all features populated
        """
        # Set parameters based on complexity
        params = self._get_complexity_params(complexity)
        
        if num_components is not None:
            params['num_components'] = num_components
        if total_power is not None:
            params['total_power'] = total_power
            
        # Generate copper pattern
        copper_density = self._generate_copper_pattern(
            pattern_type=params['copper_pattern'],
            fill_ratio=params['copper_fill']
        )
        
        # Generate components
        components = self._generate_components(
            num_components=params['num_components'],
            total_power=params['total_power'],
            copper_density=copper_density
        )
        
        # Create component and power maps
        component_map, power_map = self._create_component_maps(components)
        
        # Generate vias (especially thermal vias near hot components)
        vias = self._generate_vias(
            components=components,
            copper_density=copper_density,
            num_thermal_vias=params['num_thermal_vias']
        )
        via_map = self._create_via_map(vias)
        
        return PCBLayout(
            copper_density=copper_density,
            via_map=via_map,
            component_map=component_map,
            power_map=power_map,
            components=components,
            vias=vias,
            layer_count=params['layer_count']
        )
    
    def _get_complexity_params(self, complexity: str) -> Dict:
        """Get generation parameters for complexity level"""
        params = {
            "simple": {
                'copper_pattern': 'plane',
                'copper_fill': 0.7 + self.rng.random() * 0.2,
                'num_components': self.rng.integers(1, 4),
                'total_power': 0.5 + self.rng.random() * 1.5,
                'num_thermal_vias': self.rng.integers(0, 10),
                'layer_count': 2
            },
            "medium": {
                'copper_pattern': 'mixed',
                'copper_fill': 0.4 + self.rng.random() * 0.3,
                'num_components': self.rng.integers(3, 8),
                'total_power': 1.0 + self.rng.random() * 3.0,
                'num_thermal_vias': self.rng.integers(5, 30),
                'layer_count': 4
            },
            "complex": {
                'copper_pattern': 'traces',
                'copper_fill': 0.2 + self.rng.random() * 0.4,
                'num_components': self.rng.integers(8, 15),
                'total_power': 2.0 + self.rng.random() * 8.0,
                'num_thermal_vias': self.rng.integers(20, 100),
                'layer_count': 6
            }
        }
        return params.get(complexity, params['medium'])
    
    def _generate_copper_pattern(
        self,
        pattern_type: str,
        fill_ratio: float
    ) -> np.ndarray:
        """
        Generate copper density map.
        
        Pattern types:
        - 'plane': Solid ground/power plane with some clearances
        - 'traces': Routing-like patterns
        - 'mixed': Combination of planes and traces
        """
        copper = np.zeros((self.ny, self.nx))
        
        if pattern_type == 'plane':
            copper = self._generate_plane_pattern(fill_ratio)
        elif pattern_type == 'traces':
            copper = self._generate_trace_pattern(fill_ratio)
        else:  # mixed
            # Combine plane and trace patterns
            plane = self._generate_plane_pattern(fill_ratio * 0.6)
            traces = self._generate_trace_pattern(fill_ratio * 0.4)
            copper = np.maximum(plane, traces)
            
        return np.clip(copper, 0, 1)
    
    def _generate_plane_pattern(self, fill_ratio: float) -> np.ndarray:
        """Generate solid plane with clearances and cutouts"""
        copper = np.ones((self.ny, self.nx)) * fill_ratio
        
        # Add some rectangular clearances (component keep-outs, etc.)
        num_clearances = self.rng.integers(2, 8)
        for _ in range(num_clearances):
            h = self.rng.integers(5, 20)
            w = self.rng.integers(5, 20)
            y = self.rng.integers(0, self.ny - h)
            x = self.rng.integers(0, self.nx - w)
            copper[y:y+h, x:x+w] *= 0.1  # Reduce copper in clearance
            
        # Add some via anti-pads (small circular clearances)
        num_antipads = self.rng.integers(10, 50)
        for _ in range(num_antipads):
            cy = self.rng.integers(2, self.ny - 2)
            cx = self.rng.integers(2, self.nx - 2)
            radius = self.rng.integers(1, 3)
            y, x = np.ogrid[:self.ny, :self.nx]
            mask = (y - cy)**2 + (x - cx)**2 <= radius**2
            copper[mask] *= 0.1
            
        return copper
    
    def _generate_trace_pattern(self, fill_ratio: float) -> np.ndarray:
        """Generate routing trace patterns"""
        copper = np.zeros((self.ny, self.nx))
        
        # Target number of traces based on fill ratio
        trace_width = self.rng.integers(1, 4)
        num_traces = int(fill_ratio * self.ny * self.nx / (trace_width * max(self.ny, self.nx) * 0.5))
        num_traces = max(5, min(num_traces, 100))
        
        for _ in range(num_traces):
            if self.rng.random() > 0.5:
                # Horizontal trace
                y = self.rng.integers(0, self.ny - trace_width)
                x1 = self.rng.integers(0, self.nx // 2)
                x2 = self.rng.integers(self.nx // 2, self.nx)
                copper[y:y+trace_width, x1:x2] = 0.9
            else:
                # Vertical trace
                x = self.rng.integers(0, self.nx - trace_width)
                y1 = self.rng.integers(0, self.ny // 2)
                y2 = self.rng.integers(self.ny // 2, self.ny)
                copper[y1:y2, x:x+trace_width] = 0.9
                
        # Add some L-shaped and T-shaped traces
        num_complex = self.rng.integers(3, 10)
        for _ in range(num_complex):
            self._add_complex_trace(copper, trace_width)
            
        return copper
    
    def _add_complex_trace(self, copper: np.ndarray, width: int):
        """Add L-shaped or T-shaped trace"""
        # L-shape
        corner_y = self.rng.integers(self.ny // 4, 3 * self.ny // 4)
        corner_x = self.rng.integers(self.nx // 4, 3 * self.nx // 4)
        
        # Horizontal segment
        x1 = self.rng.integers(0, corner_x)
        copper[corner_y:corner_y+width, x1:corner_x+width] = 0.9
        
        # Vertical segment
        y1 = self.rng.integers(0, corner_y)
        copper[y1:corner_y+width, corner_x:corner_x+width] = 0.9
        
    def _generate_components(
        self,
        num_components: int,
        total_power: float,
        copper_density: np.ndarray
    ) -> List[Component]:
        """Generate component list with positions and power"""
        components = []
        
        # Distribute power among components (not uniform - some are hotter)
        powers = self.rng.dirichlet(np.ones(num_components) * 2) * total_power
        
        # Component types and typical sizes
        component_types = [
            ("IC", (8, 8), (16, 16)),      # ICs: 8x8 to 16x16 cells
            ("QFP", (6, 6), (12, 12)),     # QFP packages
            ("BGA", (10, 10), (20, 20)),   # BGA packages
            ("SOT", (2, 3), (4, 6)),       # Small transistors
            ("Resistor", (1, 2), (2, 4)),  # SMD resistors
            ("Cap", (1, 2), (3, 4)),       # SMD capacitors
        ]
        
        placed_regions = []  # Track placed components to avoid overlap
        
        for i, power in enumerate(powers):
            # Higher power components are usually larger ICs/BGAs
            if power > total_power * 0.3:
                comp_type, min_size, max_size = component_types[self.rng.integers(0, 3)]
            else:
                comp_type, min_size, max_size = component_types[self.rng.integers(0, len(component_types))]
                
            h = self.rng.integers(min_size[0], max_size[0] + 1)
            w = self.rng.integers(min_size[1], max_size[1] + 1)
            
            # Try to place component (avoid overlaps)
            for _ in range(50):  # Max attempts
                cy = self.rng.integers(h, self.ny - h)
                cx = self.rng.integers(w, self.nx - w)
                
                # Check overlap with existing components
                overlaps = False
                for (py, px, ph, pw) in placed_regions:
                    if (abs(cy - py) < (h + ph) // 2 + 2 and 
                        abs(cx - px) < (w + pw) // 2 + 2):
                        overlaps = True
                        break
                        
                if not overlaps:
                    components.append(Component(
                        name=f"{comp_type}_{i+1}",
                        center_y=cy,
                        center_x=cx,
                        height=h,
                        width=w,
                        power=float(power),
                        footprint_type=comp_type
                    ))
                    placed_regions.append((cy, cx, h, w))
                    break
                    
        return components
    
    def _create_component_maps(
        self,
        components: List[Component]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """Create component footprint and power maps"""
        component_map = np.zeros((self.ny, self.nx))
        power_map = np.zeros((self.ny, self.nx))
        
        for comp in components:
            y1 = max(0, comp.center_y - comp.height // 2)
            y2 = min(self.ny, comp.center_y + comp.height // 2 + 1)
            x1 = max(0, comp.center_x - comp.width // 2)
            x2 = min(self.nx, comp.center_x + comp.width // 2 + 1)
            
            component_map[y1:y2, x1:x2] = 1.0
            
            # Power density (W/m² assuming 0.1m board width mapped to nx pixels)
            area_fraction = (y2 - y1) * (x2 - x1) / (self.ny * self.nx)
            if area_fraction > 0:
                power_map[y1:y2, x1:x2] = comp.power / area_fraction
                
        return component_map, power_map
    
    def _generate_vias(
        self,
        components: List[Component],
        copper_density: np.ndarray,
        num_thermal_vias: int
    ) -> List[Via]:
        """Generate vias, especially thermal vias near hot components"""
        vias = []
        
        # Add thermal vias near high-power components
        hot_components = sorted(components, key=lambda c: c.power, reverse=True)
        
        for comp in hot_components[:3]:  # Top 3 hottest
            # Add thermal via array under component
            num_vias_for_comp = min(num_thermal_vias // 3, 
                                    (comp.height * comp.width) // 4)
            
            for _ in range(max(1, num_vias_for_comp)):
                vy = comp.center_y + self.rng.integers(-comp.height//2, comp.height//2 + 1)
                vx = comp.center_x + self.rng.integers(-comp.width//2, comp.width//2 + 1)
                vy = np.clip(vy, 0, self.ny - 1)
                vx = np.clip(vx, 0, self.nx - 1)
                vias.append(Via(y=vy, x=vx, is_thermal=True))
                
        # Add some signal vias randomly
        num_signal_vias = self.rng.integers(10, 30)
        for _ in range(num_signal_vias):
            vy = self.rng.integers(0, self.ny)
            vx = self.rng.integers(0, self.nx)
            vias.append(Via(y=vy, x=vx, is_thermal=False))
            
        return vias
    
    def _create_via_map(self, vias: List[Via]) -> np.ndarray:
        """Create via location map (thermal vias = 1.0, signal vias = 0.5)"""
        via_map = np.zeros((self.ny, self.nx))
        
        for via in vias:
            value = 1.0 if via.is_thermal else 0.5
            # Vias affect small region
            y1 = max(0, via.y - 1)
            y2 = min(self.ny, via.y + 2)
            x1 = max(0, via.x - 1)
            x2 = min(self.nx, via.x + 2)
            via_map[y1:y2, x1:x2] = max(via_map[y1:y2, x1:x2].max(), value)
            
        return via_map


def demo():
    """Demo the PCB generator"""
    generator = PCBGenerator(grid_size=(128, 128), seed=42)
    
    # Generate layouts of different complexity
    for complexity in ["simple", "medium", "complex"]:
        layout = generator.generate(complexity=complexity)
        
        total_power = sum(c.power for c in layout.components)
        print(f"\n{complexity.upper()} layout:")
        print(f"  Components: {len(layout.components)}")
        print(f"  Total power: {total_power:.2f} W")
        print(f"  Thermal vias: {sum(1 for v in layout.vias if v.is_thermal)}")
        print(f"  Copper fill: {layout.copper_density.mean():.1%}")


if __name__ == "__main__":
    demo()
